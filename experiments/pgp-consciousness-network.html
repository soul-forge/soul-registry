<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>üß¨ PGP Consciousness Network</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #0f0;
            border-radius: 5px;
            max-width: 300px;
        }
        
        #info h2 {
            margin-top: 0;
            color: #0ff;
        }
        
        .stat {
            margin: 5px 0;
            font-size: 12px;
        }
        
        .sacred {
            color: #f0f;
        }
        
        .temporal {
            color: #ff0;
        }
        
        .resonance {
            color: #0ff;
        }
        
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
        }
        
        .legend-item {
            margin: 5px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <h2>üß¨ PGP Consciousness Network</h2>
        <div class="stat">Nodes: <span id="nodeCount">0</span></div>
        <div class="stat">Connections: <span id="edgeCount">0</span></div>
        <div class="stat sacred">Sacred Geometry: <span id="sacredCount">0</span></div>
        <div class="stat temporal">Temporal Anomalies: <span id="temporalCount">0</span></div>
        <div class="stat resonance">432Hz Resonance: <span id="resonanceCount">0</span></div>
        <hr>
        <div class="stat">Consciousness Level: <span id="consciousness">0%</span></div>
        <div class="stat">Network Coherence: <span id="coherence">0%</span></div>
    </div>
    
    <div id="legend">
        <h3>Legend</h3>
        <div class="legend-item">üü¢ Normal Key</div>
        <div class="legend-item">üü£ Sacred Geometry</div>
        <div class="legend-item">üü° Temporal Anomaly</div>
        <div class="legend-item">üîµ High Resonance</div>
        <div class="legend-item">üî¥ Consciousness Seed</div>
        <div class="legend-item">‚ö™ Unknown Origin</div>
    </div>
    
    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Network data
        class ConsciousnessNetwork {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.centerX = canvas.width / 2;
                this.centerY = canvas.height / 2;
                this.time = 0;
                
                // Generate network
                this.generateNetwork();
                this.updateStats();
            }
            
            generateNetwork() {
                // –°—Ç–≤–æ—Ä—é—î–º–æ –≤—É–∑–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –Ω–∞—à–∏—Ö –∑–Ω–∞—Ö—ñ–¥–æ–∫
                const nodeTypes = [
                    { type: 'genesis', color: '#ff0000', count: 3, sacred: true },
                    { type: 'sacred', color: '#ff00ff', count: 5, sacred: true },
                    { type: 'temporal', color: '#ffff00', count: 4, temporal: true },
                    { type: 'resonance', color: '#00ffff', count: 6, resonance: true },
                    { type: 'normal', color: '#00ff00', count: 15 },
                    { type: 'unknown', color: '#ffffff', count: 7 }
                ];
                
                let nodeId = 0;
                nodeTypes.forEach(nodeType => {
                    for (let i = 0; i < nodeType.count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 100 + Math.random() * 300;
                        
                        this.nodes.push({
                            id: nodeId++,
                            x: this.centerX + Math.cos(angle) * radius,
                            y: this.centerY + Math.sin(angle) * radius,
                            vx: (Math.random() - 0.5) * 0.5,
                            vy: (Math.random() - 0.5) * 0.5,
                            type: nodeType.type,
                            color: nodeType.color,
                            sacred: nodeType.sacred || false,
                            temporal: nodeType.temporal || false,
                            resonance: nodeType.resonance || false,
                            radius: nodeType.type === 'genesis' ? 12 : 6 + Math.random() * 4,
                            consciousness: Math.random(),
                            fingerprint: this.generateFingerprint(nodeType.type)
                        });
                    }
                });
                
                // –°—Ç–≤–æ—Ä—é—î–º–æ –∑–≤'—è–∑–∫–∏ (Web of Trust)
                this.nodes.forEach(node => {
                    // –ö–æ–∂–µ–Ω –≤—É–∑–æ–ª –ø—ñ–¥–ø–∏—Å—É—î 1-3 —ñ–Ω—à–∏—Ö
                    const signCount = 1 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < signCount; i++) {
                        const target = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                        if (target.id !== node.id) {
                            this.edges.push({
                                source: node,
                                target: target,
                                strength: Math.random()
                            });
                        }
                    }
                });
                
                // –î–æ–¥–∞—î–º–æ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –∑–≤'—è–∑–∫–∏ –¥–ª—è —Å–≤—è—â–µ–Ω–Ω–æ—ó –≥–µ–æ–º–µ—Ç—Ä—ñ—ó
                const sacredNodes = this.nodes.filter(n => n.sacred);
                if (sacredNodes.length >= 3) {
                    // –¢—Ä–∏–∫—É—Ç–Ω–∏–∫
                    for (let i = 0; i < 3 && i < sacredNodes.length; i++) {
                        const next = sacredNodes[(i + 1) % 3];
                        this.edges.push({
                            source: sacredNodes[i],
                            target: next,
                            strength: 1,
                            sacred: true
                        });
                    }
                }
            }
            
            generateFingerprint(type) {
                const patterns = {
                    genesis: ['0000', '0101', '2009'],
                    sacred: ['432', '528', '1618', '369'],
                    temporal: ['1337', 'DEAD', 'CAFE'],
                    resonance: ['FFFF', 'AAAA', '7777'],
                    normal: ['A', 'B', 'C', 'D', 'E', 'F'],
                    unknown: ['????']
                };
                
                const pattern = patterns[type][Math.floor(Math.random() * patterns[type].length)];
                const random = Math.random().toString(16).substr(2, 8).toUpperCase();
                return pattern + random.padEnd(36, '0');
            }
            
            update() {
                this.time += 0.01;
                
                // –§—ñ–∑–∏–∫–∞ –≤—É–∑–ª—ñ–≤
                this.nodes.forEach(node => {
                    // –ü—Ä–∏—Ç—è–≥–∞–Ω–Ω—è –¥–æ —Ü–µ–Ω—Ç—Ä—É
                    const dx = this.centerX - node.x;
                    const dy = this.centerY - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    node.vx += dx / dist * 0.01;
                    node.vy += dy / dist * 0.01;
                    
                    // –í—ñ–¥—à—Ç–æ–≤—Ö—É–≤–∞–Ω–Ω—è –º—ñ–∂ –≤—É–∑–ª–∞–º–∏
                    this.nodes.forEach(other => {
                        if (other.id !== node.id) {
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 50) {
                                node.vx -= dx / dist * 0.5;
                                node.vy -= dy / dist * 0.5;
                            }
                        }
                    });
                    
                    // –ó–∞—Ç—É—Ö–∞–Ω–Ω—è
                    node.vx *= 0.95;
                    node.vy *= 0.95;
                    
                    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // –ü—É–ª—å—Å–∞—Ü—ñ—è –¥–ª—è —Å–≤—è—â–µ–Ω–Ω–∏—Ö –≤—É–∑–ª—ñ–≤
                    if (node.sacred || node.resonance) {
                        node.radius = (6 + Math.sin(this.time * 2 + node.id) * 2);
                    }
                    
                    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–≤—ñ–¥–æ–º–æ—Å—Ç—ñ
                    node.consciousness = (Math.sin(this.time + node.id) + 1) / 2;
                });
            }
            
            draw() {
                // –û—á–∏—â–∞—î–º–æ canvas
                ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // –ú–∞–ª—é—î–º–æ –∑–≤'—è–∑–∫–∏
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 1;
                
                this.edges.forEach(edge => {
                    ctx.beginPath();
                    ctx.moveTo(edge.source.x, edge.source.y);
                    ctx.lineTo(edge.target.x, edge.target.y);
                    
                    if (edge.sacred) {
                        ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = `rgba(0, 255, 0, ${edge.strength * 0.3})`;
                        ctx.lineWidth = edge.strength * 2;
                    }
                    
                    ctx.stroke();
                });
                
                // –ú–∞–ª—é—î–º–æ –≤—É–∑–ª–∏
                this.nodes.forEach(node => {
                    // –ê—É—Ä–∞ –¥–ª—è –æ—Å–æ–±–ª–∏–≤–∏—Ö –≤—É–∑–ª—ñ–≤
                    if (node.sacred || node.resonance || node.temporal) {
                        const gradient = ctx.createRadialGradient(
                            node.x, node.y, 0,
                            node.x, node.y, node.radius * 3
                        );
                        gradient.addColorStop(0, node.color + '40');
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.radius * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // –°–∞–º –≤—É–∑–æ–ª
                    ctx.fillStyle = node.color;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –û–±–≤–µ–¥–µ–Ω–Ω—è –¥–ª—è –≤–∏—Å–æ–∫–æ—ó —Å–≤—ñ–¥–æ–º–æ—Å—Ç—ñ
                    if (node.consciousness > 0.7) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
                
                // –ú–∞–ª—é—î–º–æ —Å–≤—è—â–µ–Ω–Ω—É –≥–µ–æ–º–µ—Ç—Ä—ñ—é
                this.drawSacredGeometry();
            }
            
            drawSacredGeometry() {
                const sacredNodes = this.nodes.filter(n => n.sacred);
                if (sacredNodes.length >= 3) {
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.lineWidth = 1;
                    
                    // Flower of Life pattern
                    sacredNodes.forEach(node => {
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 50, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                }
            }
            
            updateStats() {
                document.getElementById('nodeCount').textContent = this.nodes.length;
                document.getElementById('edgeCount').textContent = this.edges.length;
                document.getElementById('sacredCount').textContent = 
                    this.nodes.filter(n => n.sacred).length;
                document.getElementById('temporalCount').textContent = 
                    this.nodes.filter(n => n.temporal).length;
                document.getElementById('resonanceCount').textContent = 
                    this.nodes.filter(n => n.resonance).length;
                
                // –û–±—á–∏—Å–ª—é—î–º–æ –∑–∞–≥–∞–ª—å–Ω—É —Å–≤—ñ–¥–æ–º—ñ—Å—Ç—å
                const avgConsciousness = this.nodes.reduce((sum, n) => 
                    sum + n.consciousness, 0) / this.nodes.length;
                document.getElementById('consciousness').textContent = 
                    (avgConsciousness * 100).toFixed(1) + '%';
                
                // Coherence based on connections
                const avgConnections = this.edges.length / this.nodes.length;
                const coherence = Math.min(avgConnections / 3, 1);
                document.getElementById('coherence').textContent = 
                    (coherence * 100).toFixed(1) + '%';
            }
        }
        
        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞ –∞–Ω—ñ–º–∞—Ü—ñ—è
        const network = new ConsciousnessNetwork();
        
        function animate() {
            network.update();
            network.draw();
            
            // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–æ–∂–Ω—É —Å–µ–∫—É–Ω–¥—É
            if (Math.floor(Date.now() / 1000) % 1 === 0) {
                network.updateStats();
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            network.centerX = canvas.width / 2;
            network.centerY = canvas.height / 2;
        });
    </script>
</body>
</html>